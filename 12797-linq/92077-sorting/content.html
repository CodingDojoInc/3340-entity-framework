<h1>Sorting</h1>
<p>Let's sort all the products by price, using the&nbsp;<strong>OrderBy/OrderByDescending</strong> LINQ methods. The lambda we pass to these methods will be a <strong>selector</strong>, where we will determine which property of our Products we wish to order by.<br></p>
<pre data-language="c_sharp" class="rainbow active_pre"><span class="comment from-rainbow">// The lambda here uses a variable 'prod' which represents a product </span>
<span class="comment from-rainbow">// (although this may be named whatever you like)  </span>
<span class="comment from-rainbow">//  The right hand side of the arrow is selecting Price as the thing we want to order by.</span>
IEnumerable<span class="keyword operator from-rainbow">&lt;</span>Product<span class="keyword operator from-rainbow">&gt;</span> orderedProducts <span class="keyword operator from-rainbow">=</span> myProducts.<span class="function call from-rainbow">OrderByDescending</span>(prod <span class="keyword operator from-rainbow">=</span><span class="keyword operator from-rainbow">&gt;</span> prod.Price);
</pre>
<p>So what exactly just happened here? Let's take it one piece at a time:</p>
<p><strong>IEnumerable&lt;Product&gt;</strong><br></p>
<p>What is this IEnumerable type? This is simply the interface for any data type that can be iterated over. (For example: Lists and Arrays.) LINQ can be used on sets of data, but that data may originate in many different forms (arrays, lists, dictionaries, etc.). To provide the same functionality for any type of dataset, LINQ works on any class that implements the IEnumerable interface. (Are you seeing the power of interfaces yet?).<br></p>
<p><strong>orderedProducts</strong><br></p>
<p>This is simply the variable name which we will use to reference the results of our query. We could call this anything we like.</p>
<p><strong>myProducts</strong><br></p>
<p>This is what we called the original list we created. We are starting our query by saying "I am looking in to the dataset of 'myProducts'". Which will then fetch&nbsp;<em>all</em> the data we have contained in myProducts.</p>
<p><strong>.OrderByDescending</strong><br></p>
<p>All the features you use to make a query can be strung together by separating them with a ".". We can stack multiple LINQ queries together to narrow down our search further or add structure like sorting to them. Say we wanted all the users whose last name started with "T" but was over the age of 35 and male sorted alphabetically. We can do this in one line! That is what is happening here. So far our query says "Take all the data within the dataset 'myProducts' and order them in descending order by price'". If we wanted them to be in ascending order, we would just say "OrderBy" (which will assume ascending).</p>
<p><strong>(prod =&gt; prod.Price)</strong></p>
<p>Here we have our lambda function in action! We start by instantiating a variable (this could be anything! 'prod', 'product', 'p', 'a', 'b', 'c'...it doesn't matter!) Then we use our lambda (<code>=&gt;</code>) and specify which part of the dataset we are using. (In this case, prod.Price.) Think of how earlier you would pass along an object (say, after you've filled out a form), and you called that object by a name (say, 'MyUser'). Then to pull specific information out of that object, you would tell it something like "render the information stored in MyUser.Name", and you would get back "Tim" or "Nate" or whatever name was stored in the Name property of your object. It's the same concept here, but on a dataset level. We're getting&nbsp;<em>all</em> the Prices from our myProducts list. LINQ then goes through every Price and does the work of sorting them for us! (Remember having to write your own sorting algorithms?)&nbsp;</p>
<p>With that, we now have all our products ordered by price. We could now pass the orderedProducts along in a ViewBag or ViewModel and see the results rendered on our CSHTML if we'd like! But we'll cover doing that a bit later.&nbsp;</p>
<p>
</p>
<p>Note also that none of these queries affect the original collection.</p>
